var searchIndex = {};
searchIndex["syn"] = {"doc":"","items":[[3,"Attribute","syn","Doc-comments are promoted to attributes that have `is_sugared_doc` = true",null,null],[12,"style","","",0,null],[12,"value","","",0,null],[12,"is_sugared_doc","","",0,null],[3,"Field","","",null,null],[12,"ident","","",1,null],[12,"vis","","",1,null],[12,"attrs","","",1,null],[12,"ty","","",1,null],[3,"Variant","","",null,null],[12,"ident","","",2,null],[12,"attrs","","",2,null],[12,"data","","",2,null],[12,"discriminant","","Explicit discriminant, e.g. `Foo = 1`",2,null],[3,"Arm","","An arm of a &#39;match&#39;.",null,null],[12,"attrs","","",3,null],[12,"pats","","",3,null],[12,"guard","","",3,null],[12,"body","","",3,null],[3,"Block","","A Block (`{ .. }`).",null,null],[12,"stmts","","Statements in a block",4,null],[3,"FieldPat","","A single field in a struct pattern",null,null],[12,"ident","","The identifier for the field",5,null],[12,"pat","","The pattern the field is destructured to",5,null],[12,"is_shorthand","","",5,null],[3,"Local","","Local represents a `let` statement, e.g., `let &lt;pat&gt;:&lt;ty&gt; = &lt;expr&gt;;`",null,null],[12,"pat","","",6,null],[12,"ty","","",6,null],[12,"init","","Initializer expression to set the value, if any",6,null],[12,"attrs","","",6,null],[3,"Generics","","Represents lifetimes and type parameters attached to a declaration\nof a function, enum, trait, etc.",null,null],[12,"lifetimes","","",7,null],[12,"ty_params","","",7,null],[12,"where_clause","","",7,null],[3,"Lifetime","","",null,null],[12,"ident","","",8,null],[3,"LifetimeDef","","A lifetime definition, e.g. `&#39;a: &#39;b+&#39;c+&#39;d`",null,null],[12,"attrs","","",9,null],[12,"lifetime","","",9,null],[12,"bounds","","",9,null],[3,"TyParam","","",null,null],[12,"attrs","","",10,null],[12,"ident","","",10,null],[12,"bounds","","",10,null],[12,"default","","",10,null],[3,"WhereBoundPredicate","","A type bound.",null,null],[12,"bound_lifetimes","","Any lifetimes from a `for` binding",11,null],[12,"bounded_ty","","The type being bounded",11,null],[12,"bounds","","Trait and lifetime bounds (`Clone+Send+&#39;static`)",11,null],[3,"WhereClause","","A `where` clause in a definition",null,null],[12,"predicates","","",12,null],[3,"WhereRegionPredicate","","A lifetime predicate.",null,null],[12,"lifetime","","",13,null],[12,"bounds","","",13,null],[3,"ImplGenerics","","Returned by `Generics::split_for_impl`.",null,null],[3,"TyGenerics","","Returned by `Generics::split_for_impl`.",null,null],[3,"Crate","","",null,null],[12,"shebang","","",14,null],[12,"attrs","","",14,null],[12,"items","","",14,null],[3,"Ident","","",null,null],[3,"Abi","","",null,null],[12,"0","","",15,null],[3,"FnDecl","","Header (not the body) of a function declaration.",null,null],[12,"inputs","","",16,null],[12,"output","","",16,null],[3,"ForeignItem","","",null,null],[12,"ident","","",17,null],[12,"attrs","","",17,null],[12,"node","","",17,null],[12,"vis","","",17,null],[3,"ForeignMod","","Foreign module declaration.",null,null],[12,"abi","","",18,null],[12,"items","","",18,null],[3,"ImplItem","","",null,null],[12,"ident","","",19,null],[12,"vis","","",19,null],[12,"defaultness","","",19,null],[12,"attrs","","",19,null],[12,"node","","",19,null],[3,"Item","","An item",null,null],[12,"ident","","",20,null],[12,"vis","","",20,null],[12,"attrs","","",20,null],[12,"node","","",20,null],[3,"MethodSig","","Represents a method&#39;s signature in a trait declaration,\nor in an implementation.",null,null],[12,"unsafety","","",21,null],[12,"constness","","",21,null],[12,"abi","","",21,null],[12,"decl","","",21,null],[12,"generics","","",21,null],[3,"PathListItem","","",null,null],[12,"name","","",22,null],[12,"rename","","renamed in list, e.g. `use foo::{bar as baz};`",22,null],[3,"TraitItem","","Represents an item declaration within a trait declaration,\npossibly including a default implementation. A trait item is\neither required (meaning it doesn&#39;t have an implementation, just a\nsignature) or provided (meaning it has a default implementation).",null,null],[12,"ident","","",23,null],[12,"attrs","","",23,null],[12,"node","","",23,null],[3,"Delimited","","",null,null],[12,"delim","","The type of delimiter",24,null],[12,"tts","","The delimited sequence of token trees",24,null],[3,"Mac","","Represents a macro invocation. The Path indicates which macro\nis being invoked, and the vector of token-trees contains the source\nof the macro invocation.",null,null],[12,"path","","",25,null],[12,"tts","","",25,null],[3,"MacroInput","","",null,null],[12,"ident","","",26,null],[12,"vis","","",26,null],[12,"attrs","","",26,null],[12,"generics","","",26,null],[12,"body","","",26,null],[3,"AngleBracketedParameterData","","A path like `Foo&lt;&#39;a, T&gt;`",null,null],[12,"lifetimes","","The lifetime parameters for this path segment.",27,null],[12,"types","","The type parameters for this path segment, if present.",27,null],[12,"bindings","","Bindings (equality constraints) on associated types, if present.",27,null],[3,"BareFnArg","","An argument in a function type.",null,null],[12,"name","","",28,null],[12,"ty","","",28,null],[3,"BareFnTy","","",null,null],[12,"lifetimes","","",29,null],[12,"inputs","","",29,null],[12,"output","","",29,null],[3,"MutTy","","",null,null],[12,"ty","","",30,null],[12,"mutability","","",30,null],[3,"ParenthesizedParameterData","","A path like `Foo(A,B) -&gt; C`",null,null],[12,"inputs","","`(A, B)`",31,null],[12,"output","","`C`",31,null],[3,"Path","","A &quot;Path&quot; is essentially Rust&#39;s notion of a name.",null,null],[12,"global","","",32,null],[12,"segments","","",32,null],[3,"PathSegment","","A segment of a path: an identifier, an optional lifetime, and a set of types.",null,null],[12,"ident","","",33,null],[12,"parameters","","",33,null],[3,"PolyTraitRef","","",null,null],[12,"bound_lifetimes","","The `&#39;a` in `&lt;&#39;a&gt; Foo&lt;&amp;&#39;a T&gt;`",34,null],[12,"trait_ref","","The `Foo&lt;&amp;&#39;a T&gt;` in `&lt;&#39;a&gt; Foo&lt;&amp;&#39;a T&gt;`",34,null],[3,"QSelf","","The explicit Self type in a &quot;qualified path&quot;. The actual\npath, including the trait and the associated item, is stored\nseparately. `position` represents the index of the associated\nitem qualified with this Self type.",null,null],[12,"ty","","",35,null],[12,"position","","",35,null],[3,"TypeBinding","","Bind a type to an associated type: `A=Foo`.",null,null],[12,"ident","","",36,null],[12,"ty","","",36,null],[4,"AttrStyle","","Distinguishes between Attributes that decorate items and Attributes that\nare contained as statements within items. These two cases need to be\ndistinguished for pretty-printing.",null,null],[13,"Outer","","",37,null],[13,"Inner","","",37,null],[4,"MetaItem","","A compile-time attribute item.",null,null],[13,"Word","","Word meta item.",38,null],[13,"List","","List meta item.",38,null],[13,"NameValue","","Name value meta item.",38,null],[4,"ConstExpr","","",null,null],[13,"Call","","A function call",39,null],[13,"Binary","","A binary operation (For example: `a + b`, `a * b`)",39,null],[13,"Unary","","A unary operation (For example: `!x`, `*x`)",39,null],[13,"Lit","","A literal (For example: `1`, `&quot;foo&quot;`)",39,null],[13,"Cast","","A cast (`foo as f64`)",39,null],[13,"Path","","Variable reference, possibly containing `::` and/or type\nparameters, e.g. foo::bar::&lt;baz&gt;.",39,null],[4,"VariantData","","",null,null],[13,"Struct","","",40,null],[13,"Tuple","","",40,null],[13,"Unit","","",40,null],[4,"Visibility","","",null,null],[13,"Public","","",41,null],[13,"Inherited","","",41,null],[4,"BindingMode","","",null,null],[13,"ByRef","","",42,null],[13,"ByValue","","",42,null],[4,"BlockCheckMode","","",null,null],[13,"Default","","",43,null],[13,"Unsafe","","",43,null],[4,"CaptureBy","","A capture clause",null,null],[13,"Value","","",44,null],[13,"Ref","","",44,null],[4,"Expr","","",null,null],[13,"Box","","A `box x` expression.",45,null],[13,"Vec","","An array (`[a, b, c, d]`)",45,null],[13,"Call","","A function call",45,null],[13,"MethodCall","","A method call (`x.foo::&lt;Bar, Baz&gt;(a, b, c, d)`)",45,null],[13,"Tup","","A tuple (`(a, b, c, d)`)",45,null],[13,"Binary","","A binary operation (For example: `a + b`, `a * b`)",45,null],[13,"Unary","","A unary operation (For example: `!x`, `*x`)",45,null],[13,"Lit","","A literal (For example: `1`, `&quot;foo&quot;`)",45,null],[13,"Cast","","A cast (`foo as f64`)",45,null],[13,"Type","","Type ascription (`foo: f64`)",45,null],[13,"If","","An `if` block, with an optional else block",45,null],[13,"IfLet","","An `if let` expression with an optional else block",45,null],[13,"While","","A while loop, with an optional label",45,null],[13,"WhileLet","","A while-let loop, with an optional label",45,null],[13,"ForLoop","","A for loop, with an optional label",45,null],[13,"Loop","","Conditionless loop (can be exited with break, continue, or return)",45,null],[13,"Match","","A `match` block.",45,null],[13,"Closure","","A closure (for example, `move |a, b, c| {a + b + c}`)",45,null],[13,"Block","","A block (`{ ... }` or `unsafe { ... }`)",45,null],[13,"Assign","","An assignment (`a = foo()`)",45,null],[13,"AssignOp","","An assignment with an operator",45,null],[13,"Field","","Access of a named struct field (`obj.foo`)",45,null],[13,"TupField","","Access of an unnamed field of a struct or tuple-struct",45,null],[13,"Index","","An indexing operation (`foo[2]`)",45,null],[13,"Range","","A range (`1..2`, `1..`, `..2`, `1...2`, `1...`, `...2`)",45,null],[13,"Path","","Variable reference, possibly containing `::` and/or type\nparameters, e.g. foo::bar::&lt;baz&gt;.",45,null],[13,"AddrOf","","A referencing operation (`&amp;a` or `&amp;mut a`)",45,null],[13,"Break","","A `break`, with an optional label to break",45,null],[13,"Continue","","A `continue`, with an optional label",45,null],[13,"Ret","","A `return`, with an optional value to be returned",45,null],[13,"Mac","","A macro invocation; pre-expansion",45,null],[13,"Struct","","A struct literal expression.",45,null],[13,"Repeat","","An array literal constructed from one repeated element.",45,null],[13,"Paren","","No-op: used solely so we can pretty-print faithfully",45,null],[13,"Try","","`expr?`",45,null],[4,"MacStmtStyle","","",null,null],[13,"Semicolon","","The macro statement had a trailing semicolon, e.g. `foo! { ... };`\n`foo!(...);`, `foo![...];`",46,null],[13,"Braces","","The macro statement had braces; e.g. foo! { ... }",46,null],[13,"NoBraces","","The macro statement had parentheses or brackets and no semicolon; e.g.\n`foo!(...)`. All of these will end up being converted into macro\nexpressions.",46,null],[4,"Pat","","",null,null],[13,"Wild","","Represents a wildcard pattern (`_`)",47,null],[13,"Ident","","A `Pat::Ident` may either be a new bound variable (`ref mut binding @ OPT_SUBPATTERN`),\nor a unit struct/variant pattern, or a const pattern (in the last two cases the third\nfield must be `None`). Disambiguation cannot be done with parser alone, so it happens\nduring name resolution.",47,null],[13,"Struct","","A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.\nThe `bool` is `true` in the presence of a `..`.",47,null],[13,"TupleStruct","","A tuple struct/variant pattern `Variant(x, y, .., z)`.\nIf the `..` pattern fragment is present, then `Option&lt;usize&gt;` denotes its position.\n0 &lt;= position &lt;= subpats.len()",47,null],[13,"Path","","A possibly qualified path pattern.\nUnquailfied path patterns `A::B::C` can legally refer to variants, structs, constants\nor associated constants. Quailfied path patterns `&lt;A&gt;::B::C`/`&lt;A as Trait&gt;::B::C` can\nonly legally refer to associated constants.",47,null],[13,"Tuple","","A tuple pattern `(a, b)`.\nIf the `..` pattern fragment is present, then `Option&lt;usize&gt;` denotes its position.\n0 &lt;= position &lt;= subpats.len()",47,null],[13,"Box","","A `box` pattern",47,null],[13,"Ref","","A reference pattern, e.g. `&amp;mut (a, b)`",47,null],[13,"Lit","","A literal",47,null],[13,"Range","","A range pattern, e.g. `1...2`",47,null],[13,"Slice","","`[a, b, ..i, y, z]` is represented as:\n`Pat::Slice(box [a, b], Some(i), box [y, z])`",47,null],[13,"Mac","","A macro pattern; pre-expansion",47,null],[4,"RangeLimits","","Limit types of a range (inclusive or exclusive)",null,null],[13,"HalfOpen","","Inclusive at the beginning, exclusive at the end",48,null],[13,"Closed","","Inclusive at the beginning and end",48,null],[4,"Stmt","","",null,null],[13,"Local","","A local (let) binding.",49,null],[13,"Item","","An item definition.",49,null],[13,"Expr","","Expr without trailing semi-colon.",49,null],[13,"Semi","","",49,null],[13,"Mac","","",49,null],[4,"TraitBoundModifier","","A modifier on a bound, currently this is only used for `?Sized`, where the\nmodifier is `Maybe`. Negative bounds should also be handled here.",null,null],[13,"None","","",50,null],[13,"Maybe","","",50,null],[4,"TyParamBound","","The AST represents all type param bounds as types.\n`typeck::collect::compute_bounds` matches these against\nthe &quot;special&quot; built-in traits (see `middle::lang_items`) and\ndetects Copy, Send and Sync.",null,null],[13,"Trait","","",51,null],[13,"Region","","",51,null],[4,"WherePredicate","","A single predicate in a `where` clause",null,null],[13,"BoundPredicate","","A type binding, e.g. `for&lt;&#39;c&gt; Foo: Send+Clone+&#39;c`",52,null],[13,"RegionPredicate","","A lifetime predicate, e.g. `&#39;a: &#39;b+&#39;c`",52,null],[4,"Constness","","",null,null],[13,"Const","","",53,null],[13,"NotConst","","",53,null],[4,"Defaultness","","",null,null],[13,"Default","","",54,null],[13,"Final","","",54,null],[4,"FnArg","","An argument in a function header.",null,null],[13,"SelfRef","","",55,null],[13,"SelfValue","","",55,null],[13,"Captured","","",55,null],[13,"Ignored","","",55,null],[4,"ForeignItemKind","","An item within an `extern` block",null,null],[13,"Fn","","A foreign function",56,null],[13,"Static","","A foreign static item (`static ext: u8`)",56,null],[4,"ImplItemKind","","",null,null],[13,"Const","","",57,null],[13,"Method","","",57,null],[13,"Type","","",57,null],[13,"Macro","","",57,null],[4,"ImplPolarity","","",null,null],[13,"Positive","","`impl Trait for Type`",58,null],[13,"Negative","","`impl !Trait for Type`",58,null],[4,"ItemKind","","",null,null],[13,"ExternCrate","","An`extern crate` item, with optional original crate name.",59,null],[13,"Use","","A use declaration (`use` or `pub use`) item.",59,null],[13,"Static","","A static item (`static` or `pub static`).",59,null],[13,"Const","","A constant item (`const` or `pub const`).",59,null],[13,"Fn","","A function declaration (`fn` or `pub fn`).",59,null],[13,"Mod","","A module declaration (`mod` or `pub mod`).",59,null],[13,"ForeignMod","","An external module (`extern` or `pub extern`).",59,null],[13,"Ty","","A type alias (`type` or `pub type`).",59,null],[13,"Enum","","An enum definition (`enum` or `pub enum`).",59,null],[13,"Struct","","A struct definition (`struct` or `pub struct`).",59,null],[13,"Union","","A union definition (`union` or `pub union`).",59,null],[13,"Trait","","A Trait declaration (`trait` or `pub trait`).",59,null],[13,"DefaultImpl","","Default trait implementation.",59,null],[13,"Impl","","An implementation.",59,null],[13,"Mac","","A macro invocation (which includes macro definition).",59,null],[4,"TraitItemKind","","",null,null],[13,"Const","","",60,null],[13,"Method","","",60,null],[13,"Type","","",60,null],[13,"Macro","","",60,null],[4,"Unsafety","","",null,null],[13,"Unsafe","","",61,null],[13,"Normal","","",61,null],[4,"ViewPath","","",null,null],[13,"Simple","","`foo::bar::baz as quux`",62,null],[13,"Glob","","`foo::bar::*`",62,null],[13,"List","","`foo::bar::{a, b, c}`",62,null],[4,"FloatTy","","",null,null],[13,"F32","","",63,null],[13,"F64","","",63,null],[13,"Unsuffixed","","",63,null],[4,"IntTy","","",null,null],[13,"Isize","","",64,null],[13,"I8","","",64,null],[13,"I16","","",64,null],[13,"I32","","",64,null],[13,"I64","","",64,null],[13,"Usize","","",64,null],[13,"U8","","",64,null],[13,"U16","","",64,null],[13,"U32","","",64,null],[13,"U64","","",64,null],[13,"Unsuffixed","","",64,null],[4,"Lit","","Literal kind.",null,null],[13,"Str","","A string literal (`&quot;foo&quot;`)",65,null],[13,"ByteStr","","A byte string (`b&quot;foo&quot;`)",65,null],[13,"Byte","","A byte char (`b&#39;f&#39;`)",65,null],[13,"Char","","A character literal (`&#39;a&#39;`)",65,null],[13,"Int","","An integer literal (`1`)",65,null],[13,"Float","","A float literal (`1f64` or `1E10f64` or `1.0E10`)",65,null],[13,"Bool","","A boolean literal",65,null],[4,"StrStyle","","",null,null],[13,"Cooked","","A regular string, like `&quot;foo&quot;`",66,null],[13,"Raw","","A raw string, like `r##&quot;foo&quot;##`",66,null],[4,"BinOpToken","","",null,null],[13,"Plus","","",67,null],[13,"Minus","","",67,null],[13,"Star","","",67,null],[13,"Slash","","",67,null],[13,"Percent","","",67,null],[13,"Caret","","",67,null],[13,"And","","",67,null],[13,"Or","","",67,null],[13,"Shl","","",67,null],[13,"Shr","","",67,null],[4,"DelimToken","","A delimiter token",null,null],[13,"Paren","","A round parenthesis: `(` or `)`",68,null],[13,"Bracket","","A square bracket: `[` or `]`",68,null],[13,"Brace","","A curly brace: `{` or `}`",68,null],[4,"Token","","",null,null],[13,"Eq","","",69,null],[13,"Lt","","",69,null],[13,"Le","","",69,null],[13,"EqEq","","",69,null],[13,"Ne","","",69,null],[13,"Ge","","",69,null],[13,"Gt","","",69,null],[13,"AndAnd","","",69,null],[13,"OrOr","","",69,null],[13,"Not","","",69,null],[13,"Tilde","","",69,null],[13,"BinOp","","",69,null],[13,"BinOpEq","","",69,null],[13,"At","","",69,null],[13,"Dot","","",69,null],[13,"DotDot","","",69,null],[13,"DotDotDot","","",69,null],[13,"Comma","","",69,null],[13,"Semi","","",69,null],[13,"Colon","","",69,null],[13,"ModSep","","",69,null],[13,"RArrow","","",69,null],[13,"LArrow","","",69,null],[13,"FatArrow","","",69,null],[13,"Pound","","",69,null],[13,"Dollar","","",69,null],[13,"Question","","",69,null],[13,"Literal","","",69,null],[13,"Ident","","",69,null],[13,"Underscore","","",69,null],[13,"Lifetime","","",69,null],[13,"DocComment","","",69,null],[4,"TokenTree","","When the main rust parser encounters a syntax-extension invocation, it\nparses the arguments to the invocation as a token-tree. This is a very\nloose structure, such that all sorts of different AST-fragments can\nbe passed to syntax extensions using a uniform type.",null,null],[13,"Token","","A single token",70,null],[13,"Delimited","","A delimited sequence of token trees",70,null],[4,"Body","","",null,null],[13,"Enum","","",71,null],[13,"Struct","","",71,null],[4,"BinOp","","",null,null],[13,"Add","","The `+` operator (addition)",72,null],[13,"Sub","","The `-` operator (subtraction)",72,null],[13,"Mul","","The `*` operator (multiplication)",72,null],[13,"Div","","The `/` operator (division)",72,null],[13,"Rem","","The `%` operator (modulus)",72,null],[13,"And","","The `&amp;&amp;` operator (logical and)",72,null],[13,"Or","","The `||` operator (logical or)",72,null],[13,"BitXor","","The `^` operator (bitwise xor)",72,null],[13,"BitAnd","","The `&amp;` operator (bitwise and)",72,null],[13,"BitOr","","The `|` operator (bitwise or)",72,null],[13,"Shl","","The `&lt;&lt;` operator (shift left)",72,null],[13,"Shr","","The `&gt;&gt;` operator (shift right)",72,null],[13,"Eq","","The `==` operator (equality)",72,null],[13,"Lt","","The `&lt;` operator (less than)",72,null],[13,"Le","","The `&lt;=` operator (less than or equal to)",72,null],[13,"Ne","","The `!=` operator (not equal to)",72,null],[13,"Ge","","The `&gt;=` operator (greater than or equal to)",72,null],[13,"Gt","","The `&gt;` operator (greater than)",72,null],[4,"UnOp","","",null,null],[13,"Deref","","The `*` operator for dereferencing",73,null],[13,"Not","","The `!` operator for logical inversion",73,null],[13,"Neg","","The `-` operator for negation",73,null],[4,"FunctionRetTy","","",null,null],[13,"Default","","Return type is not specified.",74,null],[13,"Ty","","Everything else",74,null],[4,"Mutability","","",null,null],[13,"Mutable","","",75,null],[13,"Immutable","","",75,null],[4,"PathParameters","","Parameters of a path segment.",null,null],[13,"AngleBracketed","","The `&lt;&#39;a, A, B, C&gt;` in `foo::bar::baz::&lt;&#39;a, A, B, C&gt;`",76,null],[13,"Parenthesized","","The `(A, B)` and `C` in `Foo(A, B) -&gt; C`",76,null],[4,"Ty","","The different kinds of types recognized by the compiler",null,null],[13,"Slice","","A variable-length array (`[T]`)",77,null],[13,"Array","","A fixed length array (`[T; n]`)",77,null],[13,"Ptr","","A raw pointer (`*const T` or `*mut T`)",77,null],[13,"Rptr","","A reference (`&amp;&#39;a T` or `&amp;&#39;a mut T`)",77,null],[13,"BareFn","","A bare function (e.g. `fn(usize) -&gt; bool`)",77,null],[13,"Never","","The never type (`!`)",77,null],[13,"Tup","","A tuple (`(A, B, C, D, ...)`)",77,null],[13,"Path","","A path (`module::module::...::Type`), optionally\n&quot;qualified&quot;, e.g. `&lt;Vec&lt;T&gt; as SomeTrait&gt;::SomeType`.",77,null],[13,"ObjectSum","","Something like `A+B`. Note that `B` must always be a path.",77,null],[13,"PolyTraitRef","","A type like `for&lt;&#39;a&gt; Foo&lt;&amp;&#39;a Bar&gt;`",77,null],[13,"ImplTrait","","An `impl TraitA+TraitB` type.",77,null],[13,"Paren","","No-op; kept solely so that we can pretty-print faithfully",77,null],[13,"Infer","","TyKind::Infer means the type should be inferred instead of it having been\nspecified. This can appear anywhere in a type.",77,null],[5,"parse_macro_input","","",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[5,"parse_crate","","",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[5,"parse_item","","",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[5,"parse_expr","","",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[5,"parse_type","","",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[5,"parse_path","","",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[5,"parse_where_clause","","",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"to_tokens","","",0,null],[11,"to_tokens","","",38,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"name","","",0,null],[11,"fmt","","",37,null],[11,"clone","","",37,null],[11,"eq","","",37,null],[11,"fmt","","",38,null],[11,"clone","","",38,null],[11,"eq","","",38,null],[11,"ne","","",38,null],[11,"name","","",38,null],[11,"to_tokens","","",39,null],[11,"fmt","","",39,null],[11,"clone","","",39,null],[11,"eq","","",39,null],[11,"ne","","",39,null],[11,"to_tokens","","",2,null],[11,"to_tokens","","",40,null],[11,"to_tokens","","",1,null],[11,"to_tokens","","",41,null],[11,"fmt","","",2,null],[11,"clone","","",2,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"fmt","","",40,null],[11,"clone","","",40,null],[11,"eq","","",40,null],[11,"ne","","",40,null],[11,"fields","","",40,null],[11,"fields_mut","","",40,null],[11,"fmt","","",1,null],[11,"clone","","",1,null],[11,"eq","","",1,null],[11,"ne","","",1,null],[11,"fmt","","",41,null],[11,"clone","","",41,null],[11,"eq","","",41,null],[11,"to_tokens","","",45,null],[11,"to_tokens","","",3,null],[11,"to_tokens","","",47,null],[11,"to_tokens","","",5,null],[11,"to_tokens","","",42,null],[11,"to_tokens","","",44,null],[11,"to_tokens","","",4,null],[11,"to_tokens","","",43,null],[11,"to_tokens","","",49,null],[11,"to_tokens","","",6,null],[11,"fmt","","",45,null],[11,"clone","","",45,null],[11,"eq","","",45,null],[11,"ne","","",45,null],[11,"fmt","","",4,null],[11,"clone","","",4,null],[11,"eq","","",4,null],[11,"ne","","",4,null],[11,"fmt","","",43,null],[11,"clone","","",43,null],[11,"eq","","",43,null],[11,"fmt","","",49,null],[11,"clone","","",49,null],[11,"eq","","",49,null],[11,"ne","","",49,null],[11,"fmt","","",46,null],[11,"clone","","",46,null],[11,"eq","","",46,null],[11,"fmt","","",6,null],[11,"clone","","",6,null],[11,"eq","","",6,null],[11,"ne","","",6,null],[11,"fmt","","",47,null],[11,"clone","","",47,null],[11,"eq","","",47,null],[11,"ne","","",47,null],[11,"fmt","","",3,null],[11,"clone","","",3,null],[11,"eq","","",3,null],[11,"ne","","",3,null],[11,"fmt","","",44,null],[11,"clone","","",44,null],[11,"eq","","",44,null],[11,"fmt","","",48,null],[11,"clone","","",48,null],[11,"eq","","",48,null],[11,"fmt","","",5,null],[11,"clone","","",5,null],[11,"eq","","",5,null],[11,"ne","","",5,null],[11,"fmt","","",42,null],[11,"clone","","",42,null],[11,"eq","","",42,null],[11,"ne","","",42,null],[11,"to_tokens","","",7,null],[11,"to_tokens","","",78,null],[11,"to_tokens","","",79,null],[11,"to_tokens","","",8,null],[11,"to_tokens","","",9,null],[11,"to_tokens","","",10,null],[11,"to_tokens","","",51,null],[11,"to_tokens","","",12,null],[11,"to_tokens","","",52,null],[11,"to_tokens","","",11,null],[11,"to_tokens","","",13,null],[11,"fmt","","",7,null],[11,"clone","","",7,null],[11,"eq","","",7,null],[11,"ne","","",7,null],[11,"default","","",7,{"inputs":[],"output":{"name":"generics"}}],[11,"fmt","","",78,null],[11,"fmt","","",79,null],[11,"split_for_impl","","Split a type&#39;s generics into the pieces required for impl&#39;ing a trait\nfor that type.",7,null],[11,"fmt","","",8,null],[11,"clone","","",8,null],[11,"eq","","",8,null],[11,"ne","","",8,null],[11,"new","","",8,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"fmt","","",9,null],[11,"clone","","",9,null],[11,"eq","","",9,null],[11,"ne","","",9,null],[11,"new","","",9,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"fmt","","",10,null],[11,"clone","","",10,null],[11,"eq","","",10,null],[11,"ne","","",10,null],[11,"fmt","","",51,null],[11,"clone","","",51,null],[11,"eq","","",51,null],[11,"ne","","",51,null],[11,"fmt","","",50,null],[11,"clone","","",50,null],[11,"eq","","",50,null],[11,"fmt","","",12,null],[11,"clone","","",12,null],[11,"eq","","",12,null],[11,"ne","","",12,null],[11,"default","","",12,{"inputs":[],"output":{"name":"whereclause"}}],[11,"none","","",12,{"inputs":[],"output":{"name":"self"}}],[11,"fmt","","",52,null],[11,"clone","","",52,null],[11,"eq","","",52,null],[11,"ne","","",52,null],[11,"fmt","","",11,null],[11,"clone","","",11,null],[11,"eq","","",11,null],[11,"ne","","",11,null],[11,"fmt","","",13,null],[11,"clone","","",13,null],[11,"eq","","",13,null],[11,"ne","","",13,null],[11,"to_tokens","","",14,null],[11,"fmt","","",14,null],[11,"clone","","",14,null],[11,"eq","","",14,null],[11,"ne","","",14,null],[11,"to_tokens","","",80,null],[11,"fmt","","",80,null],[11,"clone","","",80,null],[11,"hash","","",80,null],[11,"new","","",80,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"from","","",80,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"from","","",80,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"from","","",80,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"as_ref","","",80,null],[11,"fmt","","",80,null],[11,"eq","","",80,null],[11,"to_tokens","","",20,null],[11,"to_tokens","","",62,null],[11,"to_tokens","","",22,null],[11,"to_tokens","","",23,null],[11,"to_tokens","","",19,null],[11,"to_tokens","","",17,null],[11,"to_tokens","","",55,null],[11,"to_tokens","","",61,null],[11,"to_tokens","","",53,null],[11,"to_tokens","","",54,null],[11,"to_tokens","","",58,null],[11,"to_tokens","","",15,null],[11,"fmt","","",20,null],[11,"clone","","",20,null],[11,"eq","","",20,null],[11,"ne","","",20,null],[11,"fmt","","",59,null],[11,"clone","","",59,null],[11,"eq","","",59,null],[11,"ne","","",59,null],[11,"fmt","","",62,null],[11,"clone","","",62,null],[11,"eq","","",62,null],[11,"ne","","",62,null],[11,"fmt","","",22,null],[11,"clone","","",22,null],[11,"eq","","",22,null],[11,"ne","","",22,null],[11,"fmt","","",61,null],[11,"clone","","",61,null],[11,"eq","","",61,null],[11,"fmt","","",53,null],[11,"clone","","",53,null],[11,"eq","","",53,null],[11,"fmt","","",54,null],[11,"clone","","",54,null],[11,"eq","","",54,null],[11,"fmt","","",15,null],[11,"clone","","",15,null],[11,"eq","","",15,null],[11,"ne","","",15,null],[11,"fmt","","",18,null],[11,"clone","","",18,null],[11,"eq","","",18,null],[11,"ne","","",18,null],[11,"fmt","","",17,null],[11,"clone","","",17,null],[11,"eq","","",17,null],[11,"ne","","",17,null],[11,"fmt","","",56,null],[11,"clone","","",56,null],[11,"eq","","",56,null],[11,"ne","","",56,null],[11,"fmt","","",23,null],[11,"clone","","",23,null],[11,"eq","","",23,null],[11,"ne","","",23,null],[11,"fmt","","",60,null],[11,"clone","","",60,null],[11,"eq","","",60,null],[11,"ne","","",60,null],[11,"fmt","","",58,null],[11,"clone","","",58,null],[11,"eq","","",58,null],[11,"fmt","","",19,null],[11,"clone","","",19,null],[11,"eq","","",19,null],[11,"ne","","",19,null],[11,"fmt","","",57,null],[11,"clone","","",57,null],[11,"eq","","",57,null],[11,"ne","","",57,null],[11,"fmt","","",21,null],[11,"clone","","",21,null],[11,"eq","","",21,null],[11,"ne","","",21,null],[11,"fmt","","",16,null],[11,"clone","","",16,null],[11,"eq","","",16,null],[11,"ne","","",16,null],[11,"fmt","","",55,null],[11,"clone","","",55,null],[11,"eq","","",55,null],[11,"ne","","",55,null],[11,"to_tokens","","",65,null],[11,"fmt","","",64,null],[11,"fmt","","",63,null],[11,"fmt","","",65,null],[11,"clone","","",65,null],[11,"eq","","",65,null],[11,"ne","","",65,null],[11,"fmt","","",66,null],[11,"clone","","",66,null],[11,"eq","","",66,null],[11,"ne","","",66,null],[11,"fmt","","",64,null],[11,"clone","","",64,null],[11,"eq","","",64,null],[11,"fmt","","",63,null],[11,"clone","","",63,null],[11,"eq","","",63,null],[11,"to_tokens","","",25,null],[11,"to_tokens","","",70,null],[11,"to_tokens","","",24,null],[11,"to_tokens","","",69,null],[11,"to_tokens","","",67,null],[11,"fmt","","",25,null],[11,"clone","","",25,null],[11,"eq","","",25,null],[11,"ne","","",25,null],[11,"fmt","","",70,null],[11,"clone","","",70,null],[11,"eq","","",70,null],[11,"ne","","",70,null],[11,"fmt","","",24,null],[11,"clone","","",24,null],[11,"eq","","",24,null],[11,"ne","","",24,null],[11,"fmt","","",69,null],[11,"clone","","",69,null],[11,"eq","","",69,null],[11,"ne","","",69,null],[11,"fmt","","",67,null],[11,"clone","","",67,null],[11,"eq","","",67,null],[11,"fmt","","",68,null],[11,"clone","","",68,null],[11,"eq","","",68,null],[11,"to_tokens","","",26,null],[11,"to_tokens","","",71,null],[11,"fmt","","",26,null],[11,"clone","","",26,null],[11,"eq","","",26,null],[11,"ne","","",26,null],[11,"fmt","","",71,null],[11,"clone","","",71,null],[11,"eq","","",71,null],[11,"ne","","",71,null],[11,"op","","",72,null],[11,"assign_op","","",72,null],[11,"to_tokens","","",72,null],[11,"op","","",73,null],[11,"to_tokens","","",73,null],[11,"fmt","","",72,null],[11,"clone","","",72,null],[11,"eq","","",72,null],[11,"fmt","","",73,null],[11,"clone","","",73,null],[11,"eq","","",73,null],[11,"to_tokens","","",77,null],[11,"to_tokens","","",75,null],[11,"to_tokens","","",32,null],[11,"to_tokens","","",33,null],[11,"to_tokens","","",76,null],[11,"to_tokens","","",27,null],[11,"to_tokens","","",36,null],[11,"to_tokens","","",31,null],[11,"to_tokens","","",34,null],[11,"to_tokens","","",29,null],[11,"to_tokens","","",28,null],[11,"fmt","","",77,null],[11,"clone","","",77,null],[11,"eq","","",77,null],[11,"ne","","",77,null],[11,"fmt","","",30,null],[11,"clone","","",30,null],[11,"eq","","",30,null],[11,"ne","","",30,null],[11,"fmt","","",75,null],[11,"clone","","",75,null],[11,"eq","","",75,null],[11,"fmt","","",32,null],[11,"clone","","",32,null],[11,"eq","","",32,null],[11,"ne","","",32,null],[11,"from","","",32,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"fmt","","",33,null],[11,"clone","","",33,null],[11,"eq","","",33,null],[11,"ne","","",33,null],[11,"from","","",33,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"fmt","","",76,null],[11,"clone","","",76,null],[11,"eq","","",76,null],[11,"ne","","",76,null],[11,"none","","",76,{"inputs":[],"output":{"name":"self"}}],[11,"fmt","","",27,null],[11,"clone","","",27,null],[11,"eq","","",27,null],[11,"ne","","",27,null],[11,"default","","",27,{"inputs":[],"output":{"name":"anglebracketedparameterdata"}}],[11,"fmt","","",36,null],[11,"clone","","",36,null],[11,"eq","","",36,null],[11,"ne","","",36,null],[11,"fmt","","",31,null],[11,"clone","","",31,null],[11,"eq","","",31,null],[11,"ne","","",31,null],[11,"fmt","","",34,null],[11,"clone","","",34,null],[11,"eq","","",34,null],[11,"ne","","",34,null],[11,"fmt","","",35,null],[11,"clone","","",35,null],[11,"eq","","",35,null],[11,"ne","","",35,null],[11,"fmt","","",29,null],[11,"clone","","",29,null],[11,"eq","","",29,null],[11,"ne","","",29,null],[11,"fmt","","",28,null],[11,"clone","","",28,null],[11,"eq","","",28,null],[11,"ne","","",28,null],[11,"fmt","","",74,null],[11,"clone","","",74,null],[11,"eq","","",74,null],[11,"ne","","",74,null]],"paths":[[3,"Attribute"],[3,"Field"],[3,"Variant"],[3,"Arm"],[3,"Block"],[3,"FieldPat"],[3,"Local"],[3,"Generics"],[3,"Lifetime"],[3,"LifetimeDef"],[3,"TyParam"],[3,"WhereBoundPredicate"],[3,"WhereClause"],[3,"WhereRegionPredicate"],[3,"Crate"],[3,"Abi"],[3,"FnDecl"],[3,"ForeignItem"],[3,"ForeignMod"],[3,"ImplItem"],[3,"Item"],[3,"MethodSig"],[3,"PathListItem"],[3,"TraitItem"],[3,"Delimited"],[3,"Mac"],[3,"MacroInput"],[3,"AngleBracketedParameterData"],[3,"BareFnArg"],[3,"BareFnTy"],[3,"MutTy"],[3,"ParenthesizedParameterData"],[3,"Path"],[3,"PathSegment"],[3,"PolyTraitRef"],[3,"QSelf"],[3,"TypeBinding"],[4,"AttrStyle"],[4,"MetaItem"],[4,"ConstExpr"],[4,"VariantData"],[4,"Visibility"],[4,"BindingMode"],[4,"BlockCheckMode"],[4,"CaptureBy"],[4,"Expr"],[4,"MacStmtStyle"],[4,"Pat"],[4,"RangeLimits"],[4,"Stmt"],[4,"TraitBoundModifier"],[4,"TyParamBound"],[4,"WherePredicate"],[4,"Constness"],[4,"Defaultness"],[4,"FnArg"],[4,"ForeignItemKind"],[4,"ImplItemKind"],[4,"ImplPolarity"],[4,"ItemKind"],[4,"TraitItemKind"],[4,"Unsafety"],[4,"ViewPath"],[4,"FloatTy"],[4,"IntTy"],[4,"Lit"],[4,"StrStyle"],[4,"BinOpToken"],[4,"DelimToken"],[4,"Token"],[4,"TokenTree"],[4,"Body"],[4,"BinOp"],[4,"UnOp"],[4,"FunctionRetTy"],[4,"Mutability"],[4,"PathParameters"],[4,"Ty"],[3,"ImplGenerics"],[3,"TyGenerics"],[3,"Ident"]]};
searchIndex["unicode_xid"] = {"doc":"Determine if a `char` is a valid identifier for a parser and/or lexer according to\n[Unicode Standard Annex #31](http://www.unicode.org/reports/tr31/) rules.","items":[[17,"UNICODE_VERSION","unicode_xid","The version of [Unicode](http://www.unicode.org/)\nthat this version of unicode-derived-property is based on.",null,null],[8,"UnicodeXID","","Methods for determining if a character is a valid identifier character.",null,null],[10,"is_xid_start","","Returns whether the specified character satisfies the &#39;XID_Start&#39;\nUnicode property.",0,null],[10,"is_xid_continue","","Returns whether the specified `char` satisfies the &#39;XID_Continue&#39;\nUnicode property.",0,null]],"paths":[[8,"UnicodeXID"]]};
searchIndex["quote"] = {"doc":"","items":[[3,"Tokens","quote","",null,null],[3,"ByteStr","","",null,null],[12,"0","","",0,null],[11,"fmt","","",1,null],[11,"clone","","",1,null],[11,"new","","",1,{"inputs":[],"output":{"name":"self"}}],[11,"append","","",1,null],[11,"append_all","","",1,null],[11,"append_separated","","",1,null],[11,"append_terminated","","",1,null],[11,"default","","",1,{"inputs":[],"output":{"name":"self"}}],[11,"fmt","","",1,null],[11,"fmt","","",0,null],[11,"to_tokens","","",0,null],[11,"to_tokens","","",1,null],[8,"ToTokens","","",null,null],[10,"to_tokens","","",2,null],[14,"quote","","",null,null]],"paths":[[3,"ByteStr"],[3,"Tokens"],[8,"ToTokens"]]};
initSearch(searchIndex);
